#!/usr/bin/env just

# --- Settings --- #
set shell := ["bash", "-euo", "pipefail", "-c"]
set positional-arguments := true
set allow-duplicate-variables := true
set windows-shell := ["C:/Program Files/Git/usr/bin/bash.exe", "-euo", "pipefail", "-c"]
set dotenv-load := true

# --- Variables --- #
project_root    := quote(justfile_directory())
output_directory := project_root / "dist" # The output artifacts lie here

system := `uname -m` + "-apple-" + os() # The tuple that swift expects

main_package := ${MAIN_BINARY} # The main artifact of the project
build_dir := project_root / ".build" # Where the building artifcats are stored
debug_bin := build_dir / current_platform / "debug" / default_bin
release_bin := build_dir / current_platform / "release" / default_bin

# â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–° #
#      Recipes      #
# â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–°â–° #

[doc('List all available recipes')]
default:
    @just --list

[doc('Build Swift package in debug mode')]
[group('build')]
build target=(system):
    @echo "ðŸ”¨ Building Swift package (debug)â€¦"
    swift build --triple '{{target}}'

[doc('Build Swift package in release mode')]
[group('build')]
build-release target=(system):
    @echo "ðŸš€ Building Swift package (release)â€¦"
    swift build -c release -Xswiftc "-whole-module-optimization" --triple '{{target}}' -Xlinker "-dead_strip"

[doc('Finalize release binary')]
[group('packaging')]
package target=(system) result_directory=(output_directory):
    just build-release {{target}}
    @echo "ðŸ“¦ Packaging release binaryâ€¦"
    @mkdir -p {{output_directory}}
    @cp {{release_bin}} "{{result_directory}}/{{main_package}}-{{target}}"
    @echo "âœ… Packaged â†’ {{result_directory}}/{{main_package}}-{{target}}"

[doc('Compress binary files in target directory')]
[group('packaging')]
compress-binaries target_directory=("."):
    #!/usr/bin/env bash

    find "${target_directory}" -maxdepth 1 -type f -print0 | while IFS= read -r -d $'\0' file; do
    # Check if the file command output indicates a binary/executable type
    if file "$file" | grep -q -E 'executable|ELF|Mach-O|shared object'; then
        # Get the base filename without the path
        filename=$(basename "$file")

        # Get the base name without version number
        basename="${filename%%-*}"

        echo "Archiving binary file: $filename"

        # Create archive with just the basename, no directory structure
        tar -czf "${file}.tar.gz" \
            -C "$(dirname "$file")" \
            -s "|^${filename}$|${basename}|" \
            "$(basename "$file")"
    fi
    done

[doc('Generate SHA256 checksums for files in a directory')]
[group('packaging')]
checksum directory=(output_directory):
    @echo "ðŸ”’ Creating checksums in {{directory}}â€¦"
    @find "{{directory}}" -type f \
        ! -name "checksums.sha256" \
        ! -name "*.sha256" \
        -exec sh -c 'sha256sum "$1" > "$1.sha256"' _ {} \;
    @echo "âœ… Checksums created!"

[doc('Run the application in debug mode')]
[group('execution')]
run +args="":
    @echo "â–¶ï¸ Running (debug)â€¦"
    swift run '{{main_package}}' '$@'

[doc('Run the application in release mode')]
[group('execution')]
run-release +args="":
    @echo "â–¶ï¸ Running (release)â€¦"
    swift run -c release -Xswiftc "-whole-module-optimization" '{{release_bin}}' '$@'

[doc('Build and install the binary to /usr/local/bin')]
[group('installation')]
install: build-release
    @echo "ðŸ’¾ Installing {{main_package}} â†’ /usr/local/binâ€¦"
    @cp '{{release_bin}}' /usr/local/bin/{{main_package}}

[doc('Force install the binary')]
[group('installation')]
install-force: build-release
    @echo "ðŸ’¾ Force installing {{main_package}} â†’ /usr/local/binâ€¦"
    @cp '{{release_bin}}' "/usr/local/bin/{{main_package}}" --force

[doc('Extract release notes from changelog for specified tag')]
[group('maintenance')]
create-notes raw_tag outfile changelog:
    #!/usr/bin/env bash

    tag_v="${raw_tag}"
    tag="${tag_v#v}" # Remove prefix v

    # Changes header for release notes
    printf "# What's new\n" > "{{outfile}}"

    if [[ ! -f "{{changelog}}" ]]; then
      echo "Error: {{changelog}} not found." >&2
      exit 1
    fi

    echo "Extracting notes for tag: {{raw_tag}} (searching for section [$tag])"
    # Use awk to extract the relevant section from the changelog
    awk -v tag="$tag" '
      # start printing when we see "## [<tag>]" (escape brackets for regex)
      $0 ~ ("^## \\[" tag "\\]") { printing = 1; next }
      # stop as soon as we hit the next "## [" section header
      printing && /^## \[/       { exit }
      # otherwise, if printing is enabled, print the current line
      printing                    { print }

      # Error handling
      END {
        if (found_section != 0) {
          # Print error to stderr
          print "Error: awk could not find section header ## [" tag "] in " changelog_file > "/dev/stderr"
          exit 1
        }
      }
    ' "{{changelog}}" >> "{{outfile}}"

    # Check if the output file has content
    if [[ -s {{outfile}} ]]; then
      echo "Successfully extracted release notes to '{{outfile}}'."
    else
      # Output a warning if no notes were found for the tag
      echo "Warning: '{{outfile}}' is empty. Is '## [$tag]' present in '{{changelog}}'?" >&2
    fi

[doc('Format all Swift source files')]
[group('maintenance')]
format:
    find . -name "*.swift" -type f -exec swift-format format -i {} +

[doc('Clean artifacts and resolve dependencies')]
[group('maintenance')]
clean:
    @echo "ðŸ§¹ Cleaning build artifactsâ€¦"
    swift package clean
    swift package resolve
    
[doc('Update Swift package dependencies')]
[group('maintenance')]
update:
    @echo "ðŸ”„ Updating Swift package dependenciesâ€¦"
    swift package update

# --- Aliases --- #
alias b := build
alias br := build-release
alias p := package
alias cb := compress-binaries
alias ch := checksum
alias r := run
alias f := format
alias rr := run-release
alias cl := clean
alias i := install
alias ifo := install-force
alias up := update
